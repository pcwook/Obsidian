
## JAVA

### 상속,오버로딩,오버라이딩,하이딩
1. 상속
2. 오버로딩
	1. 같은 메서드 명 에 인자 값을 다르게 하는 것.
		ex) add(),   add(int x),  add(int x, int y)
3. 오버라이딩 (다르게 살거야)
	1. 재정의, 상속관계에서만 존재 한다.
	2. 이름이 같은 메서드가 있을 때, 재정의 하는 것.   ex) 부모 add(), 자식 add()
4. 하이딩
	1. static 을 쓴 것.
	2. 숨기는 것.

### 생성자 (아버지가 날 낳은 형태일 경우)  ex) P p1 = new C();
1. 상속 관계이면 아버지꺼 먼저 출력 해야한다.
	- 위의 예시와 같이 인자가 없으면 부모 default 생성자를 먼저 실행
2.  만약 P p1 = new C(1);    과 같은 형태로 인자가 들어있다면
	- 자식 메서드에 인자 있는 것을 본다.  다만<span style="background:#fff88f"> super()</span> 과 같이 명시적으로 표현 했느지를 확인해야 한다.
	- 만약 명시적으로 호출하지 않았다면 부모의 default 생성자를 호출하고 자신의 인자있는 함수를 실행 하면 된다.
	- super() 로 명시적으로 언급을 했다면 인자에 맞는 부모 생성자의 메서드를 호출 하고 자신의 메서드를 마저 실행한다.
	-  <span style="background:#fff88f">참고 ) </span> 부모가 날 낳았든, 그냥 C c1 = new C(); 로 선언했든 <font color="#ffc000">생성자는 똑같이</font> 하면됨.

#### 오버라이딩 (아버지가 날 낳은 형태) ex)P p1 = new C();
1. 만약 P p1 = new C();  이라는 형태일 때 오버라이딩(재정의) 하게 되면 자식이 가진거로 사용한다.
2. 자식한테는 없지만 부모 한테는 있으면 호출가능
3. <font color="#ffc000">아버지가 날 낳은 형태 일때는 부모 한테 있는 것만 호출 가능</font>  --> 오류 (Error) 발생

#### 하이딩 (숨기다, Static달린것.)  부모가 날 낳은 형태 일때 ex)P p1 = new C();
1. public <font color="#ffc000">static</font> void func1()  이런 형태 일때는 각각 메소드를 가지고 있는 것으로 생각한다
	- 위와 같을때 p1.func1() 을 호출 하면 부모에게 있는 메소드를 호출한다.
	- 자식 메서드 사용을 하려면 C p2 = new C(); 를 사용 해서 p2.func1(); 를 호출해야한다.

#### 멥버변수 P p1 = new C(); 일때
- ![[Pasted image 20240711014418.png]]
- 이러한 형태 일때 부모 a 와 자식 a 둘다 가지고 있는 형태가 된다.
- p1.a 라고 하면 부모의 형태기 때문에 부모를 따라간다.
